package com.project.demo.service;

import java.sql.Time;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import com.project.demo.entity.Employee;
import com.project.demo.entity.Login;
import com.project.demo.entity.ShiftTime;
import com.project.demo.entity.ShiftTimeAttendance;
import com.project.demo.model.ShiftTimeModel;
import com.project.demo.repo.EmployeeRepo;
import com.project.demo.repo.LoginRepo;
import com.project.demo.repo.SalesRepo;
import com.project.demo.repo.ShiftTimeRepo;
import com.project.demo.repo.shiftTimeAttendanceRepo;

@Service
public class shiftTimeAttendanceService {

	@Autowired
	private shiftTimeAttendanceRepo shiftTimeAttendanceRepository;
	@Autowired
	private ShiftTimeRepo shiftRepository;

	private LoginService loginService;

	@Autowired
	private EmployeeRepo employeeRepository;

	private ShiftTimeModel shifTtime;

	@Autowired
	private SalesRepo salesRepository;
	@Autowired
	private LoginRepo loginRepo;
	@Autowired
	private shiftTimeAttendanceRepo attendanceRepository;

	public shiftTimeAttendanceService(@Lazy LoginService loginService) {
		this.loginService = loginService;
	}

	public void updateDateAttendance(Login login) {
		ShiftTimeAttendance attendance = login.getShiftTimeAttendanceId();
		Integer employeeId = login.getEmployeeId().getEmployeeId();

		// If attendance doesn't exist, create a new one and save it
		if (attendance == null) {
			attendance = new ShiftTimeAttendance();
			attendance.setEmployee(login.getEmployeeId());
			attendance.setAttendanceDate(java.sql.Date.valueOf(LocalDate.now()));

			attendance = shiftTimeAttendanceRepository.save(attendance);

			login.setShiftTimeAttendanceId(attendance);
			loginRepo.save(login);
		}

		// Get the nearest shift time for the employee
		ShiftTime shiftTime = findNearestShiftTimeForEmployee(employeeId, login.getLoginDateTime());

		// Calculate and set attendance data
		calculateAndSetAttendanceData(login, attendance, employeeId, shiftTime);

		shiftTimeAttendanceRepository.save(attendance);
	}

	private void calculateAndSetAttendanceData(Login login, ShiftTimeAttendance attendance, Integer employeeId,
	        ShiftTime shiftTime) {
	    LocalDate attendanceDate;

	    if (attendance.getAttendanceDate() == null) {
	        attendanceDate = LocalDate.now();
	    } else {
	        // طريقة آمنة للتحويل من Date إلى LocalDate
	        Date date = attendance.getAttendanceDate();
	        if (date instanceof java.sql.Date) {
	            // إذا كان java.sql.Date
	            attendanceDate = ((java.sql.Date) date).toLocalDate();
	        } else {
	            // إذا كان java.util.Date
	            attendanceDate = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
	        }
	    }
	    
	    // Calculate time difference between activity time and shift time
	    calculateTimeDifference(login, attendance, shiftTime);

		// active time
		Time ActiveTime = login.getActivityTime();
		attendance.setTotalActiveTime(ActiveTime);

		// Total incentive sales
		Float totalIncentiveSales = calculateTotalIncentiveSales(employeeId, attendanceDate);
		attendance.setTotalIncentiveSales(totalIncentiveSales);
	}

	// Calculate time difference between activity time and shift time
	private void calculateTimeDifference(Login login, ShiftTimeAttendance attendance, ShiftTime shiftTime) {
	    if (shiftTime != null && shiftTime.getTotalTime() != null && login.getActivityTime() != null) {
	        try {
	            // Convert activity time to minutes
	            LocalTime activityLocalTime = login.getActivityTime().toLocalTime();
	            long activityMinutes = activityLocalTime.getHour() * 60 + activityLocalTime.getMinute();
	            
	            // Convert shift total time to minutes
	            LocalTime shiftTotalLocalTime = shiftTime.getTotalTime().toLocalTime();
	            long shiftTotalMinutes = shiftTotalLocalTime.getHour() * 60 + shiftTotalLocalTime.getMinute();
	            
	            // Calculate difference
	            long timeDifferenceMinutes = activityMinutes - shiftTotalMinutes;
	            
	            System.out.println("Activity Time: " + activityLocalTime + " (" + activityMinutes + " minutes)");
	            System.out.println("Shift Time: " + shiftTotalLocalTime + " (" + shiftTotalMinutes + " minutes)");
	            System.out.println("Time Difference: " + timeDifferenceMinutes + " minutes");
	            
	            if (timeDifferenceMinutes < 0) {
	                // Less time - activity time is less than required shift time
	                long lessMinutes = Math.abs(timeDifferenceMinutes);
	                Time lessTime = Time.valueOf(String.format("%02d:%02d:00", lessMinutes / 60, lessMinutes % 60));
	                attendance.setLessTime(lessTime);
	                attendance.setOverTime(null);
	                System.out.println("Less time detected: " + lessTime);
	            } else if (timeDifferenceMinutes > 0) {
	                // Overtime - activity time is more than required shift time
	                long overMinutes = timeDifferenceMinutes;
	                Time overTime = Time.valueOf(String.format("%02d:%02d:00", overMinutes / 60, overMinutes % 60));
	                attendance.setOverTime(overTime);
	                attendance.setLessTime(null);
	                System.out.println("Overtime detected: " + overTime);
	            } else {
	                // Exact time - activity time equals shift time
	                attendance.setLessTime(null);
	                attendance.setOverTime(null);
	                System.out.println("Time is exactly as required");
	            }
	            
	        } catch (Exception e) {
	            System.err.println("Error calculating time difference: " + e.getMessage());
	            attendance.setLessTime(null);
	            attendance.setOverTime(null);
	        }
	    } else {
	        attendance.setLessTime(null);
	        attendance.setOverTime(null);
	        System.out.println("Cannot calculate overtime/less time - missing shift or activity data");
	    }
	}

	
	// دالة مختصرة تجيب مجموع ال active time من جدول login
	private void calculateAndSetTotalActiveTime(Integer employeeId, Date date) {
	    // جلب مجموع ال active time للموظف في اليوم من جدول login
	    Long totalMillis = loginRepo.sumActivityTimeByEmployeeAndDate(employeeId, date);
	    
	    if (totalMillis != null) {
	        // حفظ في جدول attendance
	        ShiftTimeAttendance attendance = attendanceRepository.findByEmployeeIdAndDate(employeeId, date);
	        if (attendance == null) {
	            attendance = new Attendance();
	            attendance.setEmployeeId(employeeId);
	            attendance.setDate(date);
	        }
	        attendance.setTotalActiveTime(new Time(totalMillis));
	        attendanceRepository.save(attendance);
	    }
	}
	
	
	
	// Find the nearest shift time for employee based on login time
	private ShiftTime findNearestShiftTimeForEmployee(Integer employeeId, LocalDateTime loginTime) {
	    try {
	        List<ShiftTime> shiftTimes = shiftRepository.findByEmployeeIdNative(employeeId);
	        
	        if (shiftTimes == null || shiftTimes.isEmpty()) {
	            System.out.println("No shift times found for employee: " + employeeId);
	            return null;
	        }

	        ShiftTime nearestShift = null;
	        long minTimeDifference = Long.MAX_VALUE;
	        LocalTime loginLocalTime = loginTime.toLocalTime();

	        for (ShiftTime shiftTime : shiftTimes) {
	            if (shiftTime.getFromTime() != null && shiftTime.getToTime() != null) {
	                LocalTime shiftFromTime = shiftTime.getFromTime().toLocalTime();
	                LocalTime shiftToTime = shiftTime.getToTime().toLocalTime();
	                
	                // Calculate time difference to shift start
	                long diffToStart = calculateTimeDifferenceInMinutes(loginLocalTime, shiftFromTime);
	                
	                // Calculate time difference to shift end
	                long diffToEnd = calculateTimeDifferenceInMinutes(loginLocalTime, shiftToTime);
	                
	                // Take the minimum difference for this shift
	                long minDiffForThisShift = Math.min(diffToStart, diffToEnd);
	                
	                System.out.println("Shift " + shiftTime.getShiftTimeId() + 
	                                 " - From: " + shiftFromTime + 
	                                 " To: " + shiftToTime +
	                                 " - Min Diff: " + minDiffForThisShift + " minutes");
	                
	                // If this shift is closer than previous ones
	                if (minDiffForThisShift < minTimeDifference) {
	                    minTimeDifference = minDiffForThisShift;
	                    nearestShift = shiftTime;
	                }
	            }
	        }

	        if (nearestShift != null) {
	            System.out.println("Nearest shift found: " + nearestShift.getShiftTimeId() + 
	                             " with time difference: " + minTimeDifference + " minutes");
	        }

	        return nearestShift;

	    } catch (Exception e) {
	        System.err.println("Error finding nearest shift for employee " + employeeId + ": " + e.getMessage());
	        return null;
	    }
	}

	// Calculate time difference in minutes between two LocalTime objects
	private long calculateTimeDifferenceInMinutes(LocalTime time1, LocalTime time2) {
	    long minutes1 = time1.getHour() * 60 + time1.getMinute();
	    long minutes2 = time2.getHour() * 60 + time2.getMinute();
	    
	    return Math.abs(minutes1 - minutes2);
	}

	// calculate total incentive sales
	private Float calculateTotalIncentiveSales(Integer employeeId, LocalDate date) {
		Employee employee = employeeRepository.findById(employeeId)
				.orElseThrow(() -> new RuntimeException("Employee not found with id: " + employeeId));

		Float incentivePercent = employee.getSalesIncentivePercent() != null ? employee.getSalesIncentivePercent()
				: 0.0f;

		if (employee.getIncentiveOnAllSales()) {
			// Incentive On All Sales=1
			ShiftTime shiftTime = getShiftTimeForEmployee(employeeId, date);
			Float allSalesDuringShift = calculateAllSalesDuringShiftTime(date, shiftTime);
			return allSalesDuringShift * (incentivePercent / 100);
		} else {

			Float allEmployeeSales = calculateAllEmployeeSalesForDate(employeeId, date);
			return allEmployeeSales * (incentivePercent / 100);
		}
	}

	// shift time for employee
	public ShiftTime getShiftTimeForEmployee(Integer employeeId, LocalDate date) {
		try {

			Optional<ShiftTime> shiftToday = shiftRepository.findByEmployeeIdAndDateNative(employeeId, date);

			if (shiftToday.isPresent()) {
				return shiftToday.get();
			}

			List<ShiftTime> employeeShifts = shiftRepository.findByEmployeeIdNative(employeeId);

			if (!employeeShifts.isEmpty()) {
				return employeeShifts.get(0);
			}

			Optional<ShiftTime> defaultShift = shiftRepository.findAnyShiftTime();

			if (defaultShift.isPresent()) {
				return defaultShift.get();
			}

			return loginService.createDummyShiftTime();

		} catch (Exception e) {
			System.out.println("ERROR in getShiftTimeForEmployee: " + e.getMessage());
			return loginService.createDummyShiftTime();
		}
	}

	private Float calculateAllSalesDuringShiftTime(LocalDate date, ShiftTime shiftTime) {
		if (shiftTime == null) {
			return 0.0f;
		}

		LocalDateTime shiftStart = LocalDateTime.of(date, shiftTime.getFromTime().toLocalTime());
		LocalDateTime shiftEnd = LocalDateTime.of(date, shiftTime.getToTime().toLocalTime());

		return salesRepository.calculateAllSalesDuringShiftTime(shiftStart, shiftEnd);
	}

	private Float calculateAllEmployeeSalesForDate(Integer employeeId, LocalDate date) {
		return salesRepository.calculateTotalSalesByEmployeeAndDate(employeeId, date);
	}

	public ShiftTimeAttendance getshittimeattendance(Integer shiftTimeAttendanceId) {
		if (shiftTimeAttendanceId == null) {
			return null;
		}

		Optional<ShiftTimeAttendance> attendance = shiftTimeAttendanceRepository.findById(shiftTimeAttendanceId);

		return attendance.orElse(null);
	}
}