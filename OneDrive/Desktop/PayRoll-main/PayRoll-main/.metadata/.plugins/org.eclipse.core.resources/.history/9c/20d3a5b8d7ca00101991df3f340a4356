package com.project.demo.service;

import java.time.LocalTime;
import java.sql.Time;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.project.demo.entity.Employee;
import com.project.demo.entity.EmployeeSalary;
import com.project.demo.entity.ShiftTime;
import com.project.demo.repo.EmployeeRepo;
import com.project.demo.repo.EmployeeSalaryRepo;
import com.project.demo.repo.SalesRepo;
import com.project.demo.repo.ShiftTimeRepo;

import jakarta.persistence.EntityNotFoundException;
import jakarta.transaction.Transactional;

@Service
@Transactional
public class EmployeeSalaryService {

	@Autowired
	private EmployeeSalaryRepo employeeSalaryRepo;

	@Autowired
	private EmployeeRepo employeeRepo;

	@Autowired
	private SalesRepo salesRepo;

	@Autowired
	private ShiftTimeRepo shiftTimeRepo;

//Calculate Employee Salary
	public EmployeeSalary calculateEmployeeSalary(Integer employeeId, Integer year, Integer month) {
		Employee employee = employeeRepo.findById(employeeId)
				.orElseThrow(() -> new EntityNotFoundException("Employee not found with id: " + employeeId));
//main salary
		Float baseSalary = calculateBaseSalary(employee, year, month);
//incentive        
		Float incentive = calculateIncentive(employee, year, month);

		return createOrUpdateSalary(employee, year, month, baseSalary, incentive);
	}

	public void updateSalaryOnAttendanceChange(Integer employeeId, Date attendanceDate) {
		java.time.LocalDate localDate = ((java.sql.Date) attendanceDate).toLocalDate();
		Integer year = localDate.getYear();
		Integer month = localDate.getMonthValue();

		calculateEmployeeSalary(employeeId, year, month);
	}

	private Float calculateBaseSalary(Employee employee, Integer year, Integer month) {
		String salaryCycle = employee.getSalaryCycle();
		Float baseSalaryRate = employee.getSalary() != null ? employee.getSalary() : 0.0f;

		// shift time
		List<ShiftTime> shiftTimes = shiftTimeRepo.findByEmployeeIdNative(employee.getEmployeeId());
		ShiftTime shiftTime = !shiftTimes.isEmpty() ? shiftTimes.get(0) : null;

		if ("DAY".equals(salaryCycle)) {
			Integer workingDays = shiftTime != null ? shiftTime.getDayIndex() * 4 : 22;
			return baseSalaryRate * workingDays;

		} else if ("HOUR".equals(salaryCycle)) {
			if (shiftTime != null) {
				Time totalTime = shiftTime.getTotalTime();
				float dailyHours = totalTime.toLocalTime().getHour() + (totalTime.toLocalTime().getMinute() / 60.0f);
				Float totalHours = dailyHours * shiftTime.getDayIndex() * 4;
				return baseSalaryRate * totalHours;
			} else {
				return baseSalaryRate * (8 * 22);
			}
		} else {
			return baseSalaryRate;
		}
	}

	private Float calculateIncentive(Employee employee, Integer year, Integer month) {
		Float incentivePercent = employee.getSalesIncentivePercent() != null ? employee.getSalesIncentivePercent()
				: 0.0f;
		Boolean incentiveOnAllSales = employee.getIncentiveOnAllSales();
		Float totalSales = 0.0f;

		if (incentivePercent == 0.0f) {
			return 0.0f;
		}

		if (Boolean.TRUE.equals(incentiveOnAllSales)) {
		    Object[] shiftTimes = getShiftTimesFromDatabase(employee.getEmployeeId());
		    LocalTime shiftStart = (LocalTime) shiftTimes[0];
		    LocalTime shiftEnd = (LocalTime) shiftTimes[1];

		    if (shiftStart != null && shiftEnd != null) {
		        totalSales = salesRepo.calculateAllSalesDuringShiftHours(year, month, shiftStart.toString(),
		                shiftEnd.toString());
		        System.out.println("Mode: ALL TEAM SALES during shift - Total Sales: " + totalSales);
		        
		        if (totalSales == null || totalSales == 0.0f) {
		            System.out.println("No sales during shift hours - No incentive");
		            return 0.0f;
		        }
		    } else {
		        totalSales = 0f;
		        System.out.println("Mode: ALL TEAM SALES (no shift) - Total Sales: " + totalSales);
		        return 0.0f;  
		    }
		} else {
		    totalSales = salesRepo.calculateEmployeeSalesByMonth(employee.getEmployeeId(), year, month);
		}

		if (totalSales == null || totalSales == 0.0f) {
		    System.out.println("No sales found - No incentive");
		    return 0.0f;
		}

		Float calculatedIncentive = totalSales * (incentivePercent / 100);
		System.out.println("Calculated Incentive: " + calculatedIncentive);
		return calculatedIncentive;
	}

// get shift time
	private Object[] getShiftTimesFromDatabase(Integer employeeId) {
		try {
			Optional<ShiftTime> shiftTime = shiftTimeRepo.findShiftTimeByEmployeeIdNative(employeeId);
			if (shiftTime.isPresent()) {
				return new Object[] { shiftTime.get().getFromTime(), shiftTime.get().getToTime() };
			}

			shiftTime = shiftTimeRepo.findShiftTimeByEmployeeIdDirect(employeeId);
			if (shiftTime.isPresent()) {
				return new Object[] { shiftTime.get().getFromTime(), shiftTime.get().getToTime() };
			}

		} catch (Exception e) {
			System.out.println("Error getting shift times: " + e.getMessage());
		}

		return new Object[] { null, null };
	}

	// create salary
	private EmployeeSalary createOrUpdateSalary(Employee employee, Integer year, Integer month, Float baseSalary,Float incentive)
	{
		Optional<EmployeeSalary> existingSalary = employeeSalaryRepo
				.findByEmployeeIdAndYearAndMonth(employee.getEmployeeId(), year, month);

		EmployeeSalary salary;
		if (existingSalary.isPresent()) {
			salary = existingSalary.get();
			salary.setMainSalary(baseSalary);
			salary.setIncentive(incentive);
			salary.setCalculatedIncentive(incentive);
		} else {
			salary = new EmployeeSalary();
			salary.setEmployeeId(employee.getEmployeeId());
			salary.setYear(year);
			salary.setMonth(month);
			salary.setSalaryDate(new Date());
			salary.setMainSalary(baseSalary);
			salary.setIncentive(incentive);
			salary.setCalculatedIncentive(incentive);
			salary.setDiscount(0f);
			salary.setReward(0f);
			salary.setSalaryLocked(false);
		}

		calculateFinalSalary(salary);
		return employeeSalaryRepo.save(salary);
	}

	// final salary
	public EmployeeSalary addFinalSalary(Integer employeeId, Integer year, Integer month, Float finalSalary) {
		EmployeeSalary employeeSalary = employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month)
				.orElseThrow(() -> new EntityNotFoundException("Salary record not found for employee: " + employeeId
						+ ", year: " + year + ", month: " + month));

		employeeSalary.setFinalSalary(finalSalary);

		return employeeSalaryRepo.save(employeeSalary);
	}

	// calculate Final Salary
	private void calculateFinalSalary(EmployeeSalary employeeSalary) {
		Float mainSalary = employeeSalary.getMainSalary() != null ? employeeSalary.getMainSalary() : 0f;
		Float incentive = employeeSalary.getIncentive() != null ? employeeSalary.getIncentive() : 0f;
		Float discount = employeeSalary.getDiscount() != null ? employeeSalary.getDiscount() : 0f;
		Float reward = employeeSalary.getReward() != null ? employeeSalary.getReward() : 0f;

		Float calculatedSalary = mainSalary + incentive + reward - discount;
		employeeSalary.setCalculatedSalary(calculatedSalary);

		if (employeeSalary.getSalaryAmountPaid() != null) {
			Float paidDifference = calculatedSalary - employeeSalary.getSalaryAmountPaid();
			employeeSalary.setSalaryDifference(paidDifference);
			employeeSalary.setCalculatedFinalSalary(paidDifference);
		}
	}

//add discount
	public EmployeeSalary addSalaryDiscount( Integer employeeId, Integer year, Integer month,Float amount,String reason) {
	    EmployeeSalary employeeSalary = getOrCreateEmployeeSalary(employeeId, year, month);

	    Float newDiscount = (employeeSalary.getDiscount() != null ? employeeSalary.getDiscount() : 0f) + amount;
	    employeeSalary.setDiscount(newDiscount);
	    employeeSalary.setCalculatedDiscount(newDiscount);
	    employeeSalary.setDiscountReason(reason);

	    calculateFinalSalary(employeeSalary);

	    return employeeSalaryRepo.save(employeeSalary);
	}
	public EmployeeSalary addSalaryReward( Integer employeeId,Integer year,Integer month,Float amount,String reason) 
	{
	    EmployeeSalary employeeSalary = getOrCreateEmployeeSalary(employeeId, year, month);

	    Float newReward = (employeeSalary.getReward() != null ? employeeSalary.getReward() : 0f) + amount;
	    employeeSalary.setReward(newReward);
	    employeeSalary.setRewardReason(reason);

	    calculateFinalSalary(employeeSalary);

	    return employeeSalaryRepo.save(employeeSalary);
	}

	// get employee salary
	private EmployeeSalary getOrCreateEmployeeSalary(Integer employeeId, Integer year, Integer month) {
	    Optional<EmployeeSalary> existingSalary =
	            employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month);

	    if (existingSalary.isPresent()) {
	        return existingSalary.get();
	    }

	    Employee employee = employeeRepo.findById(employeeId)
	            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + employeeId));

	    Float baseSalary = calculateBaseSalary(employee, year, month);
	    Float incentive = calculateIncentive(employee, year, month);

	    return createOrUpdateSalary(employee, year, month, baseSalary, incentive);
	}

	// pay
	public EmployeeSalary paySalaryDirect(Integer employeeId, Integer year, Integer month, Float amountPaid) {
		EmployeeSalary salary = employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month)
				.orElseThrow(() -> new EntityNotFoundException("Salary record not found for employee: " + employeeId
						+ ", year: " + year + ", month: " + month));

		if (Boolean.TRUE.equals(salary.getSalaryLocked())) {
			throw new RuntimeException("Salary is locked and cannot be modified");
		}

		Float currentAmountPaid = salary.getSalaryAmountPaid() != null ? salary.getSalaryAmountPaid() : 0.0f;
		Float totalAmountPaid = currentAmountPaid + amountPaid;
		salary.setSalaryAmountPaid(totalAmountPaid);

		calculateFinalSalary(salary);

		return employeeSalaryRepo.save(salary);
	}

	public Optional<EmployeeSalary> getEmployeeSalary(Integer employeeId, Integer year, Integer month) {
		return employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month);
	}

	// update main salary
	public EmployeeSalary updateBaseSalary(Integer employeeId, Integer year, Integer month, Float newBaseSalary) {
		EmployeeSalary employeeSalary = employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month)
				.orElseGet(() -> {
					EmployeeSalary newSalary = new EmployeeSalary();
					newSalary.setEmployeeId(employeeId);
					newSalary.setYear(year);
					newSalary.setMonth(month);
					newSalary.setSalaryDate(new Date());
					return newSalary;
				});

		employeeSalary.setMainSalary(newBaseSalary);
		calculateFinalSalary(employeeSalary);

		return employeeSalaryRepo.save(employeeSalary);
	}

	// lock salary

	public EmployeeSalary lockSalary(Integer employeeId, Integer year, Integer month) {
		EmployeeSalary employeeSalary = employeeSalaryRepo.findByEmployeeIdAndYearAndMonth(employeeId, year, month)
				.orElseThrow(() -> new RuntimeException("Salary not found"));

		employeeSalary.setSalaryLocked(true);
		return employeeSalaryRepo.save(employeeSalary);
	}

	public EmployeeSalary createEmployeeSalary(Employee employee) {
		EmployeeSalary employeeSalary = new EmployeeSalary();
		employeeSalary.setEmployeeId(employee.getEmployeeId());
		employeeSalary.setMainSalary(employee.getSalary());

		return employeeSalaryRepo.save(employeeSalary);
	}

}